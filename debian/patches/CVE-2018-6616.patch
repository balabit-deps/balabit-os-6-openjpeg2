Description: convertbmp: detect invalid file dimensions early
 width/length dimensions read from bmp headers are not necessarily
 valid. For instance they may have been maliciously set to very large
 values with the intention to cause DoS (large memory allocation, stack
 overflow). In these cases we want to detect the invalid size as early
 as possible.
 .
 This commit introduces a counter which verifies that the number of
 written bytes corresponds to the advertized width/length.
Author: Hugo Lefeuvre <hle@debian.org>
Origin: https://github.com/uclouvain/openjpeg/commit/8ee335227bbcaf1614124046aa25e53d67b11ec3
Bug: https://github.com/uclouvain/openjpeg/issues/1059
Bug-Debian: https://bugs.debian.org/889683
--- a/src/bin/jp2/convertbmp.c
+++ b/src/bin/jp2/convertbmp.c
@@ -499,14 +499,14 @@
 
 static OPJ_BOOL bmp_read_rle8_data(FILE* IN, OPJ_UINT8* pData, OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)
 {
-	OPJ_UINT32 x, y;
+	OPJ_UINT32 x, y, written;
 	OPJ_UINT8 *pix;
 	const OPJ_UINT8 *beyond;
 	
 	beyond = pData + stride * height;
 	pix = pData;
 	
-	x = y = 0U;
+	x = y = written = 0U;
 	while (y < height)
 	{
 		int c = getc(IN);
@@ -517,6 +517,7 @@
 			
 			for (j = 0; (j < c) && (x < width) && ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {
 				*pix = c1;
+				written++;
 			}
 		}
 		else {
@@ -543,6 +544,7 @@
 				{
 					OPJ_UINT8 c1 = (OPJ_UINT8)getc(IN);
 					*pix = c1;
+					written++;
 				}
 				if ((OPJ_UINT32)c & 1U) { /* skip padding byte */
 					getc(IN);
@@ -550,6 +552,12 @@
 			}
 		}
 	}/* while() */
+
+	if (written != width * height) {
+		fprintf(stderr, "warning, image's actual size does not match advertized one\n");
+		return OPJ_FALSE;
+	}
+
 	return OPJ_TRUE;
 }
 
