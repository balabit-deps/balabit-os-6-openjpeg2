From 21399f6b7d318fcdf4406d5e88723c4922202aa3 Mon Sep 17 00:00:00 2001
From: Young Xiao <YangX92@hotmail.com>
Date: Sat, 16 Mar 2019 19:57:27 +0800
Subject: [PATCH] convertbmp: detect invalid file dimensions early

width/length dimensions read from bmp headers are not necessarily
valid. For instance they may have been maliciously set to very large
values with the intention to cause DoS (large memory allocation, stack
overflow). In these cases we want to detect the invalid size as early
as possible.

This commit introduces a counter which verifies that the number of
written bytes corresponds to the advertized width/length.

See commit 8ee335227bbc for details.

And also,
bmp_read_rle4_data(): avoid potential infinite loop.

Signed-off-by: Young Xiao <YangX92@hotmail.com>
---
 src/bin/jp2/convertbmp.c | 10 ++++++++--
 1 file changed, 8 insertions(+), 2 deletions(-)

--- a/src/bin/jp2/convertbmp.c
+++ b/src/bin/jp2/convertbmp.c
@@ -578,29 +578,40 @@
 
 static OPJ_BOOL bmp_read_rle4_data(FILE* IN, OPJ_UINT8* pData, OPJ_UINT32 stride, OPJ_UINT32 width, OPJ_UINT32 height)
 {
-	OPJ_UINT32 x, y;
+	OPJ_UINT32 x, y, written;
 	OPJ_UINT8 *pix;
 	const OPJ_UINT8 *beyond;
 	
 	beyond = pData + stride * height;
 	pix = pData;
-	x = y = 0U;
+	x = y = written = 0U;
 	while(y < height)
 	{
 		int c = getc(IN);
-		if(c == EOF) break;
+		if(c == EOF) {
+		   return OPJ_FALSE;
+		}
 		
 		if(c) {/* encoded mode */
-			int j;
-			OPJ_UINT8 c1 = (OPJ_UINT8)getc(IN);
+      int j, c1_int;
+      OPJ_UINT8 c1;
+
+      c1_int = getc(IN);
+      if (c1_int == EOF) {
+          return OPJ_FALSE;
+      }
+      c1 = (OPJ_UINT8)c1_int;
 		
 			for (j = 0; (j < c) && (x < width) && ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {
 				*pix = (OPJ_UINT8)((j&1) ? (c1 & 0x0fU) : ((c1>>4)&0x0fU));
+				written++;
 			}
 		}
 		else { /* absolute mode */
 			c = getc(IN);
-			if(c == EOF) break;
+			if(c == EOF) {
+			   return OPJ_FALSE;
+		  }
 		
 			if(c == 0x00) { /* EOL */
 				x = 0;  y++;  pix = pData + y * stride;
@@ -609,8 +620,16 @@
 				break;
 			}
 			else if(c == 0x02) { /* MOVE by dxdy */
-				c = getc(IN);  x += (OPJ_UINT32)c;
-				c = getc(IN);  y += (OPJ_UINT32)c;
+				c = getc(IN);
+			  if (c == EOF) {
+            return OPJ_FALSE;
+        }
+				x += (OPJ_UINT32)c;
+				c = getc(IN);
+				if (c == EOF) {
+            return OPJ_FALSE;
+        }
+				y += (OPJ_UINT32)c;
 				pix = pData + y * stride + x;
 			}
 			else { /* 03 .. 255 : absolute mode */
@@ -619,16 +638,29 @@
 				
 				for (j = 0; (j < c) && (x < width) && ((OPJ_SIZE_T)pix < (OPJ_SIZE_T)beyond); j++, x++, pix++) {
 					if((j&1) == 0) {
-							c1 = (OPJ_UINT8)getc(IN);
+              int c1_int;
+              c1_int = getc(IN);
+              if (c1_int == EOF) {
+                  return OPJ_FALSE;
+              }
+              c1 = (OPJ_UINT8)c1_int;
 					}
 					*pix =  (OPJ_UINT8)((j&1) ? (c1 & 0x0fU) : ((c1>>4)&0x0fU));
+					written++;
 				}
 				if(((c&3) == 1) || ((c&3) == 2)) { /* skip padding byte */
-						getc(IN);
+						c = getc(IN);
+            if (c == EOF) {
+                return OPJ_FALSE;
+            }
 				}
 			}
 		}
 	}  /* while(y < height) */
+  if (written != width * height) {
+      fprintf(stderr, "warning, image's actual size does not match advertized one\n");
+      return OPJ_FALSE;
+  }
 	return OPJ_TRUE;
 }
 
